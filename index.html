<!DOCTYPE html>
<html>
<head>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>
<body style="margin: 0; padding: 0;">
<script>

const GAMEWIDTH = window.innerWidth;
const GAMEHEIGHT = window.innerHeight;
const FONT = "Comic Sans MS";
const FONTSCALE = (GAMEWIDTH > GAMEHEIGHT) ? 1 : 1.5;
const BOOKHEIGHT = 4 * 22;
const BOOKWIDTH = 4 * 100;
const BOOKSCALE = (GAMEWIDTH > GAMEHEIGHT) ? 0.5 : 0.85;
const OWLSCALE = (GAMEWIDTH > GAMEHEIGHT) ? 0.1 : 0.2;
const CALCULATEDBOOKHEIGHT = BOOKHEIGHT * BOOKSCALE;
const CALCULATEDBOOKWIDTH = BOOKWIDTH * BOOKSCALE;
const ACCERELATION = 0.003;
const ACCERELATIONCAP = 0.01;
const owlDownwardAcc = 0.4;
const owlFlapIncrease = 120 * owlDownwardAcc;
const pipeWidth = CALCULATEDBOOKWIDTH;
const showPipesDebug = false;
const pipeSpawnDelay = 1000;
const owlHalfWidth = 38 * (OWLSCALE * 10);
const owlHalfHeight = 38 * (OWLSCALE * 10);
const bookChoices = [];
const owlXPos = GAMEWIDTH / 4;
const bookVariance = 10;
var lastPipeSpawn = 0;
var owlUpwardMotion = 0;
var SCROLLSPEED = 5;
var lastPipeTopBookCount;
var score = 0;
var scoreText;


function registerBook(ctx, bookFileName){
    let cnt = bookChoices.length;
    ctx.load.image("book" + cnt, bookFileName);
    bookChoices.push("book" + cnt);
}

let firstPipe;
let lastPipe;
class Pipe {
    constructor(point, x, y, height, ctx){
        this.point = point; // if true, this pipe gives a point when passed.
        this.x = x;
        this.y = y;
        this.height = height;
        this.next = false;
        this.ctx = ctx;
        this.books = [];
        this.startHeight = this.y - this.height / 2;

        if (firstPipe === undefined){
            firstPipe = this;
        }
        if (lastPipe !== undefined){
            lastPipe.next = this;
        }
        lastPipe = this;
        this.createBooks(ctx);
        if(showPipesDebug && this.ctx){
            this.debugRectangle = this.ctx.add.rectangle(this.x, this.y, pipeWidth, this.height, 0xffffff);
        }
    }

    createBooks(ctx){
        let bookCount = Math.floor(this.height / CALCULATEDBOOKHEIGHT);
        for(let i = 0; i < bookCount; i++){
            let randomBookOffset = Phaser.Math.Between(-bookVariance, bookVariance);
            let randomBookString = bookChoices[Math.floor(Math.random()*bookChoices.length)];
            let book = ctx.add.image(this.x + randomBookOffset, this.startHeight + (CALCULATEDBOOKHEIGHT / 2) + i * (CALCULATEDBOOKHEIGHT), randomBookString);
            book.setScale(BOOKSCALE);
            this.books.push(book);
        }
    }

    update(){
        this.x -= SCROLLSPEED;
        if (showPipesDebug) this.debugRectangle.x = this.x;
        // Moves books to the left
        this.books.forEach(book => {
            book.x -= SCROLLSPEED;
        });

        // Check if pipe is past owl
        if (this.point && this.x < owlXPos - owlHalfWidth){
            score++;
            this.point = false;
        }

        // Check and destroy pipe if off screen
        if (this.next && this === firstPipe && this.x + pipeWidth < 0){
            firstPipe = this.next;
            for(let i = 0; i < this.books.length; i++){
                let book = this.books[i];
                book.destroy();
            }
        }
        
    }

    checkCollision(){
        let lx = this.x - pipeWidth / 2;
        let rx = this.x + pipeWidth / 2;
        let ty = this.y - this.height / 2;
        let by = this.y + this.height / 2;
        if (
            owl.x - owlHalfWidth < rx &&
            owl.x + owlHalfWidth > lx &&
            owl.y - owlHalfHeight < by &&
            owl.y + owlHalfHeight > ty
        ){
            gameOver();
        }
    }
}

let config = {
    type: Phaser.AUTO,
    width: GAMEWIDTH,
	height: GAMEHEIGHT,
    backgroundColor: 0x00aaff,
    scene: {
        preload: preload,
        create: create,
        update: update,
    }
}

var game = new Phaser.Game(config);

function preload () {
    this.load.image("bg1", "bg.png");
    this.load.image("owl", "owl.png");
    registerBook(this, "b61.png");
    registerBook(this, "b62.png");
    registerBook(this, "b63.png");
    registerBook(this, "b64.png");
}

function create () {
    bg = this.add.tileSprite(GAMEWIDTH / 2, GAMEHEIGHT - 75, GAMEWIDTH, 150, "bg1");
    owl = this.add.sprite(owlXPos, GAMEHEIGHT / 2, "owl");
    owl.setScale(OWLSCALE);
    owl.angle = 20;
    this.input.keyboard.on("keydown", owlFlap, this);
    this.input.on('pointerdown', owlFlap, this);
    
    let fontSize = FONTSCALE * 100;
    let textStyle = {font: fontSize + "px " + FONT, fill: "#ffffff", align: "center", stroke: "#000000", strokeThickness: 5};
    scoreText = this.add.text(GAMEWIDTH / 2, 20, score, textStyle);
    scoreText.setDepth(1);

}

function update() {
    bg.tilePositionX += SCROLLSPEED;
    SCROLLSPEED += Math.min(ACCERELATIONCAP, SCROLLSPEED * ACCERELATION);
    owl.y -= owlUpwardMotion;
    owlUpwardMotion -= Math.max(owlDownwardAcc, owlUpwardMotion * owlDownwardAcc);
    scoreText.setText(score);

    checkCollisionsUpdatePipes();
    managePiping(this);
}

function checkCollisionsUpdatePipes(){
    check_ground_hit();
    let curPipe = firstPipe;
    while (curPipe){
        curPipe.checkCollision();
        curPipe.update();
        curPipe = curPipe.next;   
    }
}

function owlFlap() {
    owlUpwardMotion += owlFlapIncrease;
}

function managePiping(ctx) {
    if (lastPipeSpawn > 0){
        lastPipeSpawn -= SCROLLSPEED;
    } else {
        // Spawn new pipe
        lastPipeSpawn = pipeSpawnDelay;
        let maxBookCount = Math.floor(GAMEHEIGHT / CALCULATEDBOOKHEIGHT);
        let minGapSize = Math.floor(owlHalfHeight * 2 * 3.2);
        let maxGapSize = Math.floor(owlHalfHeight * 2 * 7);
        let minGapBookCount = Math.floor(minGapSize / CALCULATEDBOOKHEIGHT) + 1;
        let maxGapBookCount = Math.floor(maxGapSize / CALCULATEDBOOKHEIGHT) + 1;
        let maxVariance = maxBookCount / 4;

        let bookTopCount;
        if (lastPipeTopBookCount) {
            bookTopCount = Phaser.Math.Between(Math.max(2, lastPipeTopBookCount - maxVariance), Math.min(maxBookCount / 2, lastPipeTopBookCount + maxVariance));
        } else {
            bookTopCount = Phaser.Math.Between(2, maxBookCount / 1.6);
            lastPipeTopBookCount = bookTopCount;
        }

        let bookBottomCount = Phaser.Math.Between(Math.max(3, maxBookCount - bookTopCount - maxGapBookCount), maxBookCount - bookTopCount - minGapBookCount);
        let topPipeHeight = bookTopCount * CALCULATEDBOOKHEIGHT;
        let bottomPipeHeight = bookBottomCount * CALCULATEDBOOKHEIGHT;
        let topPipe = new Pipe(true, GAMEWIDTH + pipeWidth + bookVariance, topPipeHeight / 2, topPipeHeight, ctx);
        let bottomPipe = new Pipe(false, GAMEWIDTH + pipeWidth + bookVariance, GAMEHEIGHT - (bottomPipeHeight / 2), bottomPipeHeight, ctx);
    }
    
    
}

function check_ground_hit(){
    if(owl.y > GAMEHEIGHT){
        gameOver();
    }
}

function gameOver(){
    alert("Game Over");
}

</script>
</body>
</html>
